#ifndef FILE_HANDLER_HEADER
#define FILE_HANDLER_HEADER

struct TplFileHandler {
    TplFileHandler(const std::string& file_output_dir_, const std::string& file_path_, const std::string& file_name_, PythonExecutor* python_executor_, TaskCounter* task_counter_):
        file_output_dir(file_output_dir_), file_path(file_path_), file_name(file_name_), python_executor(python_executor_), task_counter(task_counter_) {split_name();}
    ~TplFileHandler(){
        std::scoped_lock<std::mutex,std::mutex> rendering_lock(rendering_mutex,saving_mutex);
        for (auto generator : file_template)
            delete generator;
    }
public:

    std::string file_path;
    std::string file_name;
    std::string file_output_dir;

    std::string script_path_0;
    std::string script_path_1; 

    std::filesystem::file_time_type last_write_time;

    std::mutex loading_mutex;
    std::mutex precomputing_mutex;
    std::mutex rendering_mutex;
    std::mutex saving_mutex;

    size_t file_content_size;
    std::string_view file_content;
    std::unique_ptr<char[]> file_content_buffer;
    std::vector<uint64_t> file_line_indices = {0};

    bool data_block = false;
    uint64_t data_block_beg_index = 0;
    uint64_t data_block_end_index = 0;

    bool load_failed = false;
    bool any_render_failed = false;
    std::list<std::string> log_list;
    size_t log_width=0;

    struct Generator;
    std::vector<Generator*> file_template;
    DataFrame file_dataframe;
    std::set<std::string_view> file_variables;

    std::unordered_set<std::string> import_modules;
    std::unordered_set<std::tuple<std::string,std::string>> import_from_modules;
    std::unordered_set<std::tuple<std::string,std::string>> import_file_modules;

    PythonExecutor* python_executor;
    TaskCounter* task_counter;

    json serialized_json;

public:

    void update(){

        std::scoped_lock<std::mutex> loading_lock(loading_mutex);
        {std::scoped_lock<std::mutex> rendering_lock(rendering_mutex);}

        std::filesystem::file_time_type this_write_time = std::filesystem::last_write_time(file_path);

        if (this_write_time==last_write_time) return;

        last_write_time = this_write_time;

        load_failed = false;
        any_render_failed = false;

        log_list.clear();
        log_width=0;

        for (auto generator : file_template)
            delete generator;

        data_block = false;
        data_block_beg_index = 0;
        data_block_end_index = 0;

        file_template.clear();
        file_dataframe.clear();
        file_variables.clear();

        file_line_indices.clear();
        file_line_indices.push_back(0);

        load(); 
        if (!load_failed) parse();
        if (!load_failed){
            file_dataframe.serialize(serialized_json);
            serialized_json["import_modules"] = import_modules;
            serialized_json["import_from_modules"] = import_from_modules;
            serialized_json["import_file_modules"] = import_file_modules;
            dump();
        }
    }

    void split_name(){
        constexpr const uint8_t dfa[5][256] = {{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                               { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                               { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                               { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                               { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};
        
        bool split = false;
        uint64_t name_split_idx = 0;

        uint64_t ptr = 0;
        uint16_t transition = 0;
        uint8_t& state = *reinterpret_cast<uint8_t*>(&transition); // Least significant byte
        uint8_t& pstate = *(reinterpret_cast<uint8_t*>(&transition) + 1); // Most significant byte

        std::array<std::function<void()>,1> actions = {
            [&](){
                name_split_idx=ptr;
                split=true;
            }
        };

        std::unordered_map<uint16_t, std::vector<uint8_t>> transition_to_actions;
        for (state=0;state<5;++state){
            for (pstate=0;pstate<5;++pstate){
                transition_to_actions[transition] = {}; // Default : Null action
            }
        }

        transition = 0;

        transition_to_actions[0x0300] = {0};

        try{

            for (ptr = 0; ptr < file_name.size();++ptr) {
                const char& chr = file_name.data()[ptr];

                pstate = state;
                state = dfa[state][static_cast<uint8_t>(chr)];

                for (const uint8_t& action : transition_to_actions[transition] )
                    actions[action]();

            }

            pstate = state;
            state = dfa[state][0];

            for (const uint8_t& action : transition_to_actions[transition] )
                actions[action]();

            if (!split)
                name_split_idx = file_name.size()-4;

            script_path_0 = file_output_dir + std::string(file_name.data(),name_split_idx);
            script_path_1 = std::string(file_name.data()+name_split_idx,file_name.size()-name_split_idx-3); 

        } catch (const std::runtime_error& e) {
            log("Runtime Error during Name Parse.\n" + static_cast<std::string>(e.what()));
            load_failed = true;
        }

   }

    void load() {
        try{
            auto start = std::chrono::high_resolution_clock::now();

            std::ifstream file(file_path, std::ios::ate);

            if (!file.is_open()) {
                log("Failed to open file: \n\n" + std::system_category().message(errno) + "\n");
                load_failed = true;
                return;
            }

            std::streamsize size = file.tellg();
            file.seekg(0, std::ios::beg);
            file_content_buffer = std::make_unique<char[]>(size+1);
            
            bool read_load_failed = static_cast<bool>(file.read(file_content_buffer.get(), size));
            auto error_number = errno;
            file.close();

            if (error_number) {
                log("Failed to read file: " + std::to_string(error_number) + "\n\n" + std::system_category().message(error_number));
                load_failed = true;
                return;
            }

            /*
             Assessing the file size in the way above gives a count higher than the byte count the file
            actualy has... Probably because of filesystem blocking scheme.
             To assess what the file's actual size is, the snippet bellow performs a binary search to determine
            the first 0x00 byte in the oversized buffer.
            */
            size_t rside = size ;
            size_t lside = 0;

            while (lside < rside) {
                size_t mid = lside + ((rside - lside)>>1);
                if (file_content_buffer[mid] == 0) {
                    rside = mid;
                } else {
                    lside = mid + 1;
                }
            }

            file_content_size = lside+1; // +1 to "append" an extra 0x00 byte after the file's data in order to properly parse it in the funtion bellow.
            file_content = std::string_view(file_content_buffer.get(),file_content_size);

            auto end = std::chrono::high_resolution_clock::now();

            log_time("Successfully loaded file into memory.",start,end);

        } catch (const std::runtime_error& e) {
            log("Runtime Error during Load:\n\n" + static_cast<std::string>(e.what()));
            load_failed = true;
        }   
    }

public:
    struct Cache{
        std::unordered_map<uint64_t, std::string> error_messages;
        std::unordered_map<uint64_t, bool> render_failed;
        std::unordered_map<uint64_t, std::vector<std::string>> values;
        std::unordered_map<uint64_t, uint64_t> ptr;
        void push(uint64_t script_index, const std::string& value) {values[script_index].push_back(value);}
        std::string fetch(uint64_t script_index) {return values[script_index][ptr[script_index]++];}
    };
    Cache cache;

    struct Generator {
        virtual void write(uint64_t, std::unique_ptr<std::ofstream>&, Cache&) const = 0;
        virtual bool precompute(uint64_t, const DataFrame&, PythonExecutor*, Cache&) = 0;
    };

    struct PlainText : Generator {
        PlainText(const std::string_view& s):buffer(s){}
        void write(uint64_t script_index, std::unique_ptr<std::ofstream>& out_file, Cache& cache) const override {
            (*out_file) << buffer;
        }
        bool precompute(uint64_t script_index, const DataFrame& dataframe, PythonExecutor* python_executor, Cache& cache) override {
            return false;
        }
        std::string_view buffer;
    };

    struct Expression : Generator {
        Expression(const std::string_view& s):buffer(s){}
        void write(uint64_t script_index, std::unique_ptr<std::ofstream>& out_file, Cache& cache) const override {
            (*out_file) << cache.fetch(script_index);
        }
        bool precompute(uint64_t script_index, const DataFrame& dataframe, PythonExecutor* python_executor, Cache& cache) override {
            if (cache.error_messages.find(script_index)!=cache.error_messages.end()) return true;

            std::string expression(buffer);
            python_executor->evaluate(expression);
            if (python_executor->failed()){
                cache.error_messages[script_index] += "Failed eval: " + expression + "\n" + python_executor->get_error() + "\n";
                return true;
            }

            cache.push(script_index, python_executor->get_eval());

            return false;
        }
        std::string_view buffer;
    };

    struct Line : Generator {
        Line(int64_t pre_delta_, int64_t pos_delta_):pre_delta(pre_delta_),pos_delta(pos_delta_){}
        void write(uint64_t script_index, std::unique_ptr<std::ofstream>& out_file, Cache& cache) const override {
            (*out_file) << cache.fetch(script_index);
        }
        bool precompute(uint64_t script_index, const DataFrame& dataframe, PythonExecutor* python_executor, Cache& cache) override {
            if (cache.error_messages.find(script_index)!=cache.error_messages.end()) return true;
            
            line += pre_delta;
            cache.push(script_index,std::to_string(line));
            line += pos_delta;
            
            return false;
        };
        int64_t pre_delta,pos_delta;
        static uint64_t line;
    };

    struct LineSet : Generator {
        LineSet(uint64_t num_): num(num_) {}
        void write(uint64_t script_index, std::unique_ptr<std::ofstream>& out_file, Cache& cache) const override {}
        bool precompute(uint64_t script_index, const DataFrame& dataframe, PythonExecutor* python_executor, Cache& cache) override {
            if (cache.error_messages.find(script_index)!=cache.error_messages.end()) return true;
            
            Line::line = num;
            
            return false;
        };
        uint64_t num;
    };

    struct For : Generator {
        For(const std::string_view& s, int64_t beg_, int64_t end_, int64_t stp_, std::stack<std::vector<Generator*>*>& template_stk): 
            buffer(s), beg(beg_), end(end_), stp(stp_) {
                template_stk.push(&inner_template);
            }
        ~For() {
            for (auto generator : inner_template)
                delete generator;
        }
        void write(uint64_t script_index, std::unique_ptr<std::ofstream>& out_file, Cache& cache) const override {
            for (int64_t var_val=beg; var_val<end; var_val+=stp){
                for (auto generator : inner_template)
                    generator->write(script_index,out_file,cache);
            }
        }
        bool precompute(uint64_t script_index, const DataFrame& dataframe, PythonExecutor* python_executor, Cache& cache) override {
            if (cache.error_messages.find(script_index)!=cache.error_messages.end()) return true;
            
            std::string var(buffer);
            for (int64_t var_val=beg; var_val<end; var_val+=stp){
                python_executor->execute(var+"="+std::to_string(var_val));
                for (auto generator : inner_template)
                    if(generator->precompute(script_index,dataframe,python_executor,cache)) return true;
            }
            
            return false;
        };
        std::vector<Generator*> inner_template;
        std::string_view buffer;
        int64_t beg,end,stp;        
    };

    // struct If : Generator {
    //     If(const std::string_view& s std::stack<std::vector<Generator*>*>& template_stk): 
    //         buffer(s){template_stk.push(&inner_template);}
    //     ~If() {
    //         for (auto generator : inner_template)
    //             delete generator;
    //     }
    //     void write(const std::unordered_map<uint64_t, std::unique_ptr<std::ofstream>>& out_files) const override {
    //         if (cache.fetch() == "True") {
    //             for (auto generator : inner_template)
    //                 generator->write(out_files,cache);
    //         }
    //     }
    //     bool compute(uint64_t script_index, const DataFrame& dataframe, PythonExecutor* python_executor) const override {
    //         if (cache.error_messages.find(script_index)!=cache.error_messages.end()) return true;

    //         python_executor->evaluate(condition);

    //         std::string condition(buffer);
    //         python_executor->evaluate(expression);
    //         if (python_executor->failed()){
    //             cache.error_messages[script_index] += "Failed eval: " + expression + "\n" + python_executor->get_error() + "\n";
    //             return true;
    //         }

    //         cache.push(python_executor->get_eval());

    //         if (python_executor->get_eval() == "True") {
    //             for (auto generator : inner_template)
    //                 if (generator->compute(script_index, dataframe, python_executor)) return true;
    //         }

    //         return false;
    //     }

    // private:
    //     std::string_view buffer; // Condition expression as a string
    //     std::vector<Generator*> inner_template; // Generators to run if the condition is true
    // };

    void parse() {
        constexpr const uint8_t dfa[27][256] = {
            {10, 5, 5, 5, 5, 5, 5, 5, 5,22, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,22, 5, 5, 5, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5},
            {10, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 2, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5},
            { 8,12,12,12,12,12,12,12,12,11, 8,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,11,12,12,12, 3,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12},
            {10, 9, 9, 9, 9, 9, 9, 9, 9, 9,23, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 4, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9},
            {10, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5},
            {10, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5},
            {10, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5},
            { 8,12,12,12,12,12,12,12,12,11, 8,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,11,12,12,12, 3,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12},
            { 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8},
            { 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9},
            {10, 9, 9, 9, 9, 9, 9, 9, 9,10,10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9},
            { 8,12,12,12,12,12,12,12,12,11, 8,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,11,12,12,12, 9,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12},
            { 8,12,12,12,12,12,12,12,12,12, 8,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,17,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12},
            { 8,12,12,12,12,12,12,12,12,12, 8,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,17,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,14,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12},
            { 8,12,12,12,12,12,12,12,12,12, 8,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,17,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,15,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12},
            { 8,12,12,12,12,12,12,12,12,12, 8,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,17,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,16,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12},
            { 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20, 9, 9, 9, 9,20, 9,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9},
            { 8,12,12,12,12,12,12,12,12,12, 8,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,18,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12},
            {10, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,19, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5},
            { 8,12,12,12,12,12,12,12,12,12, 8,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,19,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12},
            { 8,12,12,12,12,12,12,12,12,12, 8,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,17,12,12,12,12,12,12,12,12,12,12,12,20,20,20,20,20,20,20,20,20,20,12,12,12,12,12,12,12,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,12,12,12,12,20,12,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12},
            { 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,23, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,24, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9},
            {10, 5, 5, 5, 5, 5, 5, 5, 5,22, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,22, 5, 5, 5, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5},
            { 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,23, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,24, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9},
            { 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,25, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9},
            { 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,26, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9},
            { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5}
        };
        const char* file_content_beg = file_content_buffer.get();

        uint64_t ptr = 0;
        uint16_t transition = 0;
        uint8_t& state  = *(reinterpret_cast<uint8_t*>(&transition) + 0); // Least significant byte
        uint8_t& pstate = *(reinterpret_cast<uint8_t*>(&transition) + 1); // Most significant byte
        
        std::stack<uint64_t> ptr_stk;
        ptr_stk.push(0);

        uint64_t id_ptr = 0;

        uint64_t line_num = 0;

        uint64_t a=0,b=1,c=1;
        std::string_view s,ps;

        uint64_t var_str = 0;
        uint64_t var_end = 0;
        uint64_t count_start = 0;
        uint64_t count_end = 0;

        uint64_t beg=0,end=0;

        std::vector<std::string_view> data_block_buffer;

        std::stack<std::vector<Generator*>*> template_stk;
        template_stk.push(&file_template) ;

        std::unordered_map<std::string,std::function<void()>> actions = {
            {"new_line",[&](){
                ++line_num;
                file_line_indices.push_back(ptr + 1);
            }},
            {"push_next",[&](){
                ptr_stk.push(ptr+1);
            }},
            {"push_l",[&](){
                ptr_stk.push(file_line_indices[line_num]-1);
            }},
            {"push",[&](){
                ptr_stk.push(ptr);
            }},
            {"pop",[&](){
                ptr_stk.pop();
            }},
            {"PlainText",[&](){
                if (!ps.empty())
                    template_stk.top()->push_back(new PlainText(ps));
            }},
            {"Expression",[&](){
                template_stk.top()->push_back(new Expression(s));
            }},
            {"Line",[&](){
                template_stk.top()->push_back(new Line(a,b));
            }},
            {"LineSet",[&](){
                template_stk.top()->push_back(new LineSet(a));
            }},
            {"For",[&](){
                template_stk.top()->push_back(new For(s,a,b,c,template_stk));
            }},
            {"check_data_block",[&](){
                if (data_block){
                    log("Error: Multiple data blocks detected.",line_num,ptr - file_line_indices[line_num]);
                    load_failed = true;
                    return;
                }
                data_block_beg_index = ptr;
                data_block = true;
            }},
            {"push_data_block",[&](){
                data_block_buffer.emplace_back(s);
            }},
            {"commit_data_block",[&](){
                data_block_end_index = ptr;
                if (deserialize(data_block_buffer)){
                    log("Error: Failed to decode data block.",line_num,ptr - file_line_indices[line_num]);
                    load_failed = true;
                }
            }},
            {"variable",[&](){
                file_variables.insert(s);
                file_dataframe.insert_column(std::string(s));
            }},
            {"fetch",[&](){
                end = ptr_stk.top();
                ptr_stk.pop();

                beg = ptr_stk.top();
                ptr_stk.pop();
            }},
            {"reset",[&](){
                a = 0;
                b = 1;
                c = 1;
            }},
            {"a++",[&](){
                a = 1;
            }},
            {"a--",[&](){
                a = -1;
            }},
            {"b++",[&](){
                b = 1;
            }},
            {"b--",[&](){
                b = -1;
            }},
            {"a",[&](){
                a = std::stoi(std::string(file_content_beg+beg,end-beg));
            }},
            {"b",[&](){
                b = std::stoi(std::string(file_content_beg+beg,end-beg));
            }},
            {"c",[&](){
                c = std::stoi(std::string(file_content_beg+beg,end-beg));
            }},
            {"s",[&](){
                s = {file_content_beg+beg,end-beg};
            }},
            {"ps",[&](){
                ps = {file_content_beg+beg,end-beg};
            }},
            {"invalid_identifier",[&](){
                log("Error: Invalid identifier.",line_num,ptr - file_line_indices[line_num], ptr - file_line_indices[line_num] - 4);
                load_failed = true;
            }},
            {"invalid_number",[&](){
                beg = ptr_stk.top();

                log("Error: Invalid number literal.",line_num,ptr - file_line_indices[line_num], beg - file_line_indices[line_num]);
                load_failed = true;
            }},
            {"invalid_data",[&](){
                log("Error: Invalid data char.",line_num,ptr - file_line_indices[line_num]);
                load_failed = true;
            }},
            {"invalid_data_f",[&](){
                beg = ptr_stk.top();
                log("Error: Invalid data chars.",line_num,ptr - file_line_indices[line_num], beg - file_line_indices[line_num]);
                load_failed = true;
            }},
            {"invalid_expression",[&](){
                log("Error: invalid_expression.",line_num,ptr - file_line_indices[line_num],ptr_stk.top() - file_line_indices[line_num]);
                load_failed = true;
            }},
            {"invalid_syntax",[&](){
                log("Error: Invalid syntax.",line_num,ptr - file_line_indices[line_num]);
                load_failed = true;
            }},
            {"invalid_syntax_f",[&](){
                beg = ptr_stk.top();
                log("Error: Invalid syntax.",line_num,ptr - file_line_indices[line_num], beg - file_line_indices[line_num]);
                load_failed = true;
            }},
            {"close",[&](){
                if(template_stk.size()>1)
                    template_stk.pop();
                else{
                    beg = ptr_stk.top();
                    log("Error: No opened loops to close.",line_num,ptr - file_line_indices[line_num],beg - file_line_indices[line_num]);
                    load_failed = true;
                }
            }},
            {"open_expression",[&](){
                log("Error: Expression not closed.",line_num, ptr - file_line_indices[line_num]);
                load_failed = true;
            }},
            {"open_for",[&](){
                beg = ptr_stk.top();
                log("Error: Incomplete FOR declaration.",line_num,ptr - file_line_indices[line_num], beg - file_line_indices[line_num]);
                load_failed = true;
            }},
            {"open_set",[&](){
                beg = ptr_stk.top();
                log("Error: Incomplete LINESET declaration.",line_num,ptr - file_line_indices[line_num], beg - file_line_indices[line_num]);
                load_failed = true;
            }},
        };


        // std::unordered_map<uint16_t, std::vector<uint8_t>> transition_to_actions;
        std::unordered_map<uint16_t, std::vector<std::string>> transition_to_actions;

        for (pstate=0;pstate<27;++pstate){
            state = 0;
            transition_to_actions[transition] = {"new_line"};
            for (state=1;state<27;++state)
                    transition_to_actions[transition] = {};
        }

        transition = 0;

        //
        transition_to_actions[0x0001] = {"push"};
        transition_to_actions[0x1601] = {"push"};
        transition_to_actions[0x0506] = {"push"};

        transition_to_actions[0x0100] = {"pop","new_line"};
        transition_to_actions[0x0105] = {"pop"};

        transition_to_actions[0x0600] = {"pop","new_line"};
        transition_to_actions[0x0605] = {"pop"};

        transition_to_actions[0x0304] = {"pop"};

        transition_to_actions[0x000A] = {"push","fetch","ps","PlainText"};
        transition_to_actions[0x160A] = {"push","fetch","ps","PlainText"};
        transition_to_actions[0x010A] = {"pop","push","fetch","ps","PlainText"};
        transition_to_actions[0x050A] = {"push","fetch","ps","PlainText"};
        transition_to_actions[0x060A] = {"pop","push","fetch","ps","PlainText"};
        transition_to_actions[0x030A] = {"pop","push","fetch","ps","PlainText"};
        transition_to_actions[0x040A] = {"push","fetch","ps","PlainText"};

        // Expression

        transition_to_actions[0x0208] = {"open_expression"};
        transition_to_actions[0x0708] = {"open_expression"};
        transition_to_actions[0x0B08] = {"open_expression"};
        transition_to_actions[0x0B09] = {"invalid_expression"};
        transition_to_actions[0x0C08] = {"open_expression"};
        transition_to_actions[0x0D08] = {"open_expression"};
        transition_to_actions[0x0E08] = {"open_expression"};
        transition_to_actions[0x0F08] = {"open_expression"};
        transition_to_actions[0x1008] = {"open_expression"};
        transition_to_actions[0x1009] = {"invalid_identifier"};
        transition_to_actions[0x1108] = {"open_expression"};
        transition_to_actions[0x1308] = {"open_expression"};
        transition_to_actions[0x1408] = {"open_expression"};

        transition_to_actions[0x020C] = {"push"};
        transition_to_actions[0x020D] = {"push"};
        transition_to_actions[0x070C] = {"push"};
        transition_to_actions[0x070D] = {"push"};
        transition_to_actions[0x0B0C] = {"push"};
        transition_to_actions[0x0B0D] = {"push"};

        transition_to_actions[0x0C11] = {"push"};
        transition_to_actions[0x0D11] = {"push"};
        transition_to_actions[0x0E11] = {"push"};
        transition_to_actions[0x0F11] = {"push"};

        transition_to_actions[0x110C] = {"pop"};
        transition_to_actions[0x110D] = {"pop"};
        transition_to_actions[0x1213] = {"pop"};

        transition_to_actions[0x1200] = {
            "fetch","s",
            "fetch","ps",
            "PlainText","Expression",
            "push","new_line"
        };
        transition_to_actions[0x1205] = {
            "fetch","s",
            "fetch","ps",
            "PlainText","Expression",
            "push"
        };
        transition_to_actions[0x120A] = {
            "fetch","s",
            "fetch","ps",
            "PlainText","Expression"
        };

        transition_to_actions[0x1014] = {"push"};
        transition_to_actions[0x140C] = {"push","fetch","s","variable"};
        transition_to_actions[0x1411] = {"push","fetch","s","variable","push"};

        // Data Block

        transition_to_actions[0x0309] = {"invalid_data"};
        transition_to_actions[0x0309] = {"invalid_data"};
        transition_to_actions[0x1509] = {"invalid_data"};
        transition_to_actions[0x1709] = {"invalid_data"};
        transition_to_actions[0x1809] = {"invalid_data_f"};
        transition_to_actions[0x1909] = {"invalid_data_f"};

        transition_to_actions[0x0317] = {"new_line","check_data_block"};
        transition_to_actions[0x0315] = {"check_data_block","push"};
        transition_to_actions[0x1715] = {"push"};

        transition_to_actions[0x1717] = {
            "new_line",
        };
        transition_to_actions[0x1517] = {
            "new_line",
            "push","fetch","s",
            "push_data_block"
        };
        transition_to_actions[0x1518] = {
            "push","fetch","s",
            "push_data_block"
        };
        transition_to_actions[0x1A05] = {
            "commit_data_block",
            "fetch","ps",
            "PlainText",
            "push"
        };

        try{

            auto start = std::chrono::high_resolution_clock::now();

            for (ptr = 0; ptr < file_content_size;++ptr) {
                const char& chr = file_content_beg[ptr];

                pstate = state;
                state = dfa[state][static_cast<uint8_t>(chr)];

                for (const auto& action : transition_to_actions[transition])
                    actions[action]();

                if (load_failed) {return;}
            }

            auto end = std::chrono::high_resolution_clock::now();
            log_time("Successfully parsed file.",start,end);

        } catch (const std::runtime_error& e) {
            log("Runtime Error during Parse.\n" + static_cast<std::string>(e.what()));
            load_failed = true;
        }

    }

public:

    void indexed_render(const std::vector<int64_t>& script_indices){
        if (!file_dataframe.row_count()) {
            log("Tried to render but dataframe is empty...");
            return;
        }
        if (load_failed) {
            log("Tried to render but load/parse failed...");
            return;
        }

        {std::scoped_lock<std::mutex> loading_lock(loading_mutex);}
        std::scoped_lock<std::mutex> rendering_lock(rendering_mutex);

        try{
            std::string successful_listing =  "\nSuccessfully rendered file(s): \n";
            std::string failed_open_listing =  "\nError : Failed to open file(s):\n";
            std::string failed_render_listing =  "\nError : Failed to render file(s):\n";

            bool any_unnopen = false, any_error = false, any_succeess = false;

            std::mutex unnopen_mutex, error_mutex, succeess_mutex;
            
            std::list<std::thread> renderers;

            task_counter->add(script_indices.size());
            
            auto start = std::chrono::high_resolution_clock::now();
            
            for (int64_t i : script_indices){
                renderers.emplace_back([=,
                    &successful_listing,&failed_open_listing,&failed_render_listing,
                    &any_unnopen,&any_error,&any_succeess,
                    &unnopen_mutex,&error_mutex,&succeess_mutex
                ]() {
                    uint64_t script_index = abs_index(i);

                    std::ostringstream oss;
                    oss << script_path_0 << "."
                        << std::setw(3) << std::setfill('0') << script_index+1
                        << script_path_1 << "py";
                    std::string script_path = oss.str();

                    if (cache.error_messages.find(script_index)!=cache.error_messages.end()){
                        cache.render_failed[script_index] = true;
                        std::scoped_lock<std::mutex> lock(error_mutex);
                        failed_render_listing += "    " + file_name + ": script " + std::to_string(script_index+1) + "\n" + cache.error_messages[script_index] + "\n";
                        any_error = true;
                        task_counter->sub();
                        return;
                    }

                    auto out_file = std::make_unique<std::ofstream>(script_path);
                    if (out_file->is_open()) {

                        cache.ptr[script_index] = 0;

                        for (const auto& generator : file_template)
                            generator->write(script_index, out_file, cache);

                        cache.render_failed[script_index] = false;
                        std::scoped_lock<std::mutex> lock(succeess_mutex);
                        successful_listing += "    " + file_name + ":" + std::to_string(script_index+1) + "\n";
                        any_succeess = true;
                    } else {
                        cache.render_failed[script_index] = true;
                        std::scoped_lock<std::mutex> lock(unnopen_mutex);
                        failed_open_listing += "    " + script_path + "\n";
                        any_unnopen = true;
                    }
                    task_counter->sub();
                });
            }

            for (auto& renderer : renderers)
                if (renderer.joinable()) renderer.join();

            auto end = std::chrono::high_resolution_clock::now();
            
            if (any_succeess)
                log_time(successful_listing,start,end);

            if (any_unnopen)
                log(failed_open_listing);

            if (any_error)
                log(failed_render_listing);

            any_render_failed = any_error || any_unnopen;

        } catch (const std::runtime_error& e) {
            log("Runtime Error during Render.\n" + static_cast<std::string>(e.what()));
            load_failed = true;
        }
    }

    void render(){
        std::vector<int64_t> all_script_indices;
        all_script_indices.reserve(file_dataframe.row_count());
        for (uint64_t i=0; i<file_dataframe.row_count(); ++i)
            all_script_indices.push_back(static_cast<int64_t>(i));
        indexed_render(all_script_indices);
    }

public:

    void precompute(){
        if (!file_dataframe.row_count() || load_failed)
            return;
        std::thread t([&](){
            std::scoped_lock<std::mutex> loading_lock(precomputing_mutex);
            try {
                for (uint64_t script_index : file_dataframe.modded_indices){

                    auto it = cache.error_messages.find(script_index); 
                    if (it !=cache.error_messages.end())
                        cache.error_messages.erase(it);

                    cache.values[script_index].clear();
                    cache.ptr[script_index] = 0;

                    Line::line = 0;

                    python_executor->execute("script="+std::to_string(script_index));
                    for (const auto& [var,value] : file_dataframe.get_map(script_index)){
                        uint8_t tries = 8;
                        while (true){
                            python_executor->execute("var_"+var+"="+value);
                            if (python_executor->failed()){
                                cache.error_messages[script_index] += "Failed to set: var_" + var + " = " + value + "\n";
                                cache.error_messages[script_index] += python_executor->get_error() + "\n";
                                break;
                            }
                            python_executor->evaluate("var_"+var+"=="+value);
                            if (python_executor->get_eval()=="True") break;
                            --tries;
                        }
                        if (!tries){
                            cache.error_messages[script_index] += "Failed to set: var_" + var + " = " + value + "\n";
                            cache.error_messages[script_index] += "Attempts depleated.\n";
                            break;
                        }
                    }
                    if (python_executor->failed()) continue;
                    
                    for (auto generator : file_template)
                        if (generator->precompute(script_index,file_dataframe, python_executor, cache)) break;
                }
                file_dataframe.modded_indices.clear();
            } catch (const std::runtime_error& e) {
                log("Runtime Error during Precompute.\n" + static_cast<std::string>(e.what()));
                load_failed = true;
            }
        });
        t.detach();
    }

    void full_precompute(){
        if (!file_dataframe.row_count() || load_failed)
            return;
        std::thread t([&](){
            std::scoped_lock<std::mutex> loading_lock(precomputing_mutex);
            try {
                for (uint64_t script_index=0; script_index<file_dataframe.row_count(); ++script_index){

                    auto it = cache.error_messages.find(script_index); 
                    if (it !=cache.error_messages.end())
                        cache.error_messages.erase(it);

                    cache.values[script_index].clear();
                    cache.ptr[script_index] = 0;

                    Line::line = 0;

                    python_executor->execute("script="+std::to_string(script_index));
                    for (const auto& [var,value] : file_dataframe.get_map(script_index)){
                        uint8_t tries = 8;
                        while (true){
                            python_executor->execute("var_"+var+"="+value);
                            if (python_executor->failed()){
                                cache.error_messages[script_index] += "Failed to set: var_" + var + " = " + value + "\n";
                                cache.error_messages[script_index] += python_executor->get_error() + "\n";
                                break;
                            }
                            python_executor->evaluate("var_"+var+"=="+value);
                            if (python_executor->get_eval()=="True") break;
                            --tries;
                        }
                        if (!tries){
                            cache.error_messages[script_index] += "Failed to set: var_" + var + " = " + value + "\n";
                            cache.error_messages[script_index] += "Attempts depleated.\n";
                            break;
                        }
                    }
                    if (python_executor->failed()) continue;
                    
                    for (auto generator : file_template)
                        if (generator->precompute(script_index,file_dataframe, python_executor, cache)) break;
                }
                file_dataframe.modded_indices.clear();
            } catch (const std::runtime_error& e) {
                log("Runtime Error during Precompute.\n" + static_cast<std::string>(e.what()));
                load_failed = true;
            }
        });
        t.detach();
    }

public:

    void dump() {
        std::thread t([&]() {

            std::scoped_lock<std::mutex> saving_lock(saving_mutex);

            std::string serialized_str = serialized_json.dump();
            std::vector<uint8_t> serialized_data(serialized_str.begin(), serialized_str.end());
            std::vector<uint16_t> compressed_data;
            buffer_compress(serialized_data, compressed_data);
            std::vector<uint8_t> encoded_data;
            buffer_encode(compressed_data, encoded_data);
            uint64_t encoded_size = encoded_data.size();
            uint64_t num_blocks = (encoded_size+127)/128;
            const char* buffer;

            std::string modified_content;
            modified_content.reserve(file_content_size + encoded_size + num_blocks/*added \n*/ + 20);

            buffer = file_content.data();
            if (data_block){
                if (data_block_beg_index!=0)
                    modified_content.append(buffer, data_block_beg_index);
                modified_content += "\n";
            } else {
                modified_content.append(file_content.data(), file_content_size-1);
                modified_content += "\n\n$$$\n";
            }

            buffer = reinterpret_cast<const char*>(encoded_data.data());
            for (uint64_t i=0; i<num_blocks; ++i){
                uint64_t beg_idx = 128*i;
                uint64_t end_idx = std::min(128*(i+1),encoded_size);
                uint64_t length = end_idx-beg_idx;
                modified_content.append(buffer + beg_idx, length);
                modified_content += "\n";
            }
            modified_content += "$$$";

            buffer = file_content.data();
            if (data_block){
                if (data_block_end_index!=file_content_size)
                    modified_content.append(buffer+ data_block_end_index, file_content_size - 1 - data_block_end_index);
            }

     
            std::ofstream file_out(file_path, std::ios::trunc);
            if (!file_out.is_open()) {
              std::cerr << "Error: Unable to open file for writing.\n";
              return;
            }

            file_out.write(modified_content.data(), modified_content.size());
            file_out.close();
        });
        t.detach();
    }

    void save_data() {
        file_dataframe.serialize(serialized_json);
        dump();
    }

    void save_modules() {
        serialized_json["import_modules"] = import_modules;
        serialized_json["import_from_modules"] = import_from_modules;
        serialized_json["import_file_modules"] = import_file_modules;
        dump();
    }

    bool deserialize(const std::vector<std::string_view>& data_block_buffer) {
        try {

            std::string encoded_str;
    
            uint64_t total_size = 0;
            for (const auto& string_view : data_block_buffer)
                total_size += string_view.size();
            encoded_str.reserve(total_size);
            for (const auto& string_view : data_block_buffer)
                encoded_str.append(string_view);

            std::vector<uint8_t> encoded_data(encoded_str.begin(),encoded_str.end());
            std::vector<uint16_t> compressed_data;
            if (buffer_decode(encoded_data,compressed_data)) return true;
            std::vector<uint8_t> serialized_data;
            if (buffer_decompress(compressed_data,serialized_data)) return true;
            std::string serialized_str(serialized_data.begin(),serialized_data.end());

            json j = json::parse(serialized_str);

            if (file_dataframe.deserialize(j)) return true;

            for (const auto& item : j["import_modules"]) 
                import_modules.insert(item.get<std::string>());

            for (const auto& item : j["import_from_modules"]) {
                std::string first = item[0].get<std::string>();
                std::string second = item[1].get<std::string>();
                import_from_modules.insert(std::make_tuple(first, second));
            }

            for (const auto& item : j["import_file_modules"]) {
                std::string first = item[0].get<std::string>();
                std::string second = item[1].get<std::string>();
                import_file_modules.insert(std::make_tuple(first, second));
            }

            serialized_json = std::move(j);

            return false;
        } catch (const json::parse_error& e) {
            return true;
        } catch (const std::exception& e) {
            return true;
        }
    }



public:

    uint64_t abs_index(int64_t index) const {
        if (index < 0) index += file_dataframe.row_count();
        if ((index < 0)  || (static_cast<uint64_t>(index) >= file_dataframe.row_count())) throw pybind11::index_error("Index out of range");
        return index;
    }

public:

    void log_time(const std::string& message, std::chrono::time_point<std::chrono::high_resolution_clock> start, std::chrono::time_point<std::chrono::high_resolution_clock> end){
        uint64_t time_count = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();

        std::string time_unit;

        if (time_count < 1000) {
            time_unit = "ns";
        } else if (time_count < 1000000) {
            time_count /= 1000;
            time_unit = "us";
        } else if (time_count < 1000000000) {
            time_count /= 1000000;
            time_unit = "ms";
        } else {
            time_count /= 1000000000;
            time_unit = "s";
        }

        log(message+"\n\nTime taken: " + std::to_string(time_count) + " " + time_unit);
    }

    void log(const std::string& message, int64_t line_num = -1, int64_t at = -1, int64_t from = -1) {
        std::string log_block;

        if (line_num != -1) {
            uint64_t str_idx = file_line_indices[line_num];
            int64_t len = 0;
            while (file_content_buffer[str_idx+len] != '\n' && str_idx+len < file_content_size-1) ++len;

            if (at > -1) {

                int64_t window_size = 32;
                int64_t half_window = 16;
                int64_t lower_bound = std::max(static_cast<int64_t>(0), at - half_window);
                int64_t upper_bound = std::min(len, at + half_window);

                if (upper_bound - lower_bound < window_size) {
                    if (lower_bound == 0)
                        upper_bound = std::min(len, lower_bound + window_size);
                    if (upper_bound == len)
                        lower_bound = std::max(static_cast<int64_t>(0), upper_bound - window_size);
                }

                std::string line(file_content.substr(str_idx+lower_bound, upper_bound-lower_bound));

                if (from != -1) {
                    if (from > at) {
                        int64_t limit = std::min(upper_bound,from);
                        line = line + std::string(at - lower_bound, ' ') + "^" + std::string(limit - at, '~');
                    } else {
                        int64_t limit = std::max(lower_bound,from);
                        line = line + std::string(from - lower_bound, ' ') + std::string(at - limit, '~') + "^";
                    }
                }
                else {
                    line = line + "\n" + std::string(at - lower_bound, ' ') + "^";
                }
                
                log_block += "Line " + std::to_string(line_num + 1) + " :\n" + line + "\nmessage:\n";
            } else {
                if (len<=32){
                    log_block += "Line " + std::to_string(line_num + 1) + " :\n" + std::string(file_content.substr(str_idx, len)) + "\nmessage:\n";
                } else {
                    log_block += "Line " + std::to_string(line_num + 1) + "\nmessage:\n";
                }
            }

        }

        log_block += message;

        std::stringstream ss(log_block);
        std::string line_log;

        while (getline(ss, line_log, '\n')) {
            log_width = std::max(log_width, line_log.size());
        }

        log_list.push_back(std::move(log_block));
    }

public:

    std::string get_log() const {

        std::string log_string;
        const std::string bar(log_width, '-');

        for (const std::string& log_block : log_list) {
            log_string += bar + "\n\n" + log_block + "\n\n";
        }

        return log_string;
    }

    std::vector<std::string> get_vars() const {
        std::vector<std::string> variables;
        variables.reserve(file_variables.size());
        for (const auto& view : file_variables)
            variables.emplace_back(view);
        return variables;
    }

    bool render_failed() {
        return any_render_failed;
    }

    bool render_failed(int64_t row) {
        uint64_t abs_row = abs_index(row);
        return any_render_failed && cache.render_failed[abs_row];
    }

public:

    void undo()                                                                                     {file_dataframe.undo();precompute();}
    void redo()                                                                                     {file_dataframe.redo();precompute();}
    void clear_dataframe()                                                                          {file_dataframe.clear();precompute();}
    void clear_dataframe_indices(const std::list<std::tuple<int64_t,std::string>>& cell_indices)    {file_dataframe.clear_cells(cell_indices);precompute();}
    void clear_dataframe_indices(const std::list<std::tuple<int64_t,int64_t>>& cell_indices)        {file_dataframe.clear_cells(cell_indices);precompute();}
    void insert_column(const std::string& col)                                                      {file_dataframe.insert_column(col);precompute();}
    void insert_rows(int64_t num_rows)                                                              {file_dataframe.insert_rows(num_rows);precompute();}
    void insert_rows(const std::list<int64_t>& rows)                                                {file_dataframe.insert_rows(rows);precompute();}
    void remove_rows(const std::list<int64_t>& rows)                                                {file_dataframe.remove_rows(rows);precompute();}
    void duplicate_rows(const std::list<int64_t>& rows)                                             {file_dataframe.duplicate_rows(rows);precompute();}
    void set(int64_t row, const std::string& col, const std::string& val)                           {file_dataframe.set(row,col,val);precompute();}
    void set(int64_t row, int64_t col, const std::string& val)                                      {file_dataframe.set(row,col,val);precompute();}
    void set(const std::list<std::tuple<int64_t, std::string, std::string>>& cell_values)           {file_dataframe.set(cell_values); precompute();}
    void set(const std::list<std::tuple<int64_t, int64_t, std::string>>& cell_values)               {file_dataframe.set(cell_values); precompute();}
    
    std::string get(int64_t row, const std::string& col)                                            {return file_dataframe.get(row,col);}
    std::string get(int64_t row, int64_t col)                                                       {return file_dataframe.get(row,col);}
    uint64_t row_count() const                                                                      {return file_dataframe.row_count();}
    uint64_t col_count() const                                                                      {return file_dataframe.col_count();}

};

uint64_t TplFileHandler::Line::line = 0;

#endif